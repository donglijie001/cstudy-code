[Toc]

# 01 温故知新

计算机的核心：CPU、内存和I/O控制芯片。



![image-20230506140307450](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230506140307450.png)

运行库使用操作系统提供的系统调用接口，系统调用接口在实现中往往以软件中断的方式提供。

## 02 编译和链接

比如对于下面这段程序：

```
#include <stdio.h>
int main(){
	printf("Hello world!\n");
	return 0;
}
```

运行结果：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230507220735498.png" alt="image-20230507220735498" style="zoom:50%;" />

上述过程可以分解为4个步骤：预处理（Prepressing）、编译（Compilation）、汇编（Assembly）、链接（Linking）。

![image-20230507221011980](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230507221011980.png)

### 2.1.1 预编译

将源代码文件hello.c和相关的头文件，如stdio.h等被预编译器cpp预编译成一个.i文件。

预编译的过程相当于如下指令：

```
gcc -E hello.c -o hello.i
或者
cpp hello.c > hello.i
```

预编译主要的处理规则：

- 将所有的#define 删除，并展开所有的宏定义。
- 处理所有条件预编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”。
- 处理#include预编译指令，将被包含的文件插入到该预编译指令功能的位置（这个过程是递归进行的，也就说被包含的文件还可能包含其他文件）。
- 删除所有的注释
- 添加行号和文件名标识，比如#2“hello.c” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或者警告时能够显示行号。
- 保留所有的#pragma编译器指令。

### 2.1.2 编译

编译过程就是把预处理完的文件通过一系列词法分析、语法分析、语义分析及优化后产生相应的汇编代码文件。对应的命令就是：

```
gcc -S hello.i -o hello.s
gcc -S hello.c -o hello.s
```

现代版本的gcc把预编译和编译合成一个步骤，使用一个叫cc1的程序来完成这两个步骤。cc1程序在linux中位于/usr/lib/gcc/i686-linux-gnu/5目录下。而对于c++来说，对应的程序叫做cc1plus。

### 2.1.3 汇编

汇编器是将汇编代码转换为机器可以执行的指令，每个汇编语句几乎都对应一条机器指令，所以汇编过程相对于编译器来讲比较简单，它没有复杂的语法也没有语义，也不需要做指令优化。对应的命令：

```
as hello.s -o hello.o
gcc -c hello.s -o hello.o
gcc -c hello.c -o hello.o
```

### 2.1.4 链接

这是一个很复杂的过程，后面详细讲解。

## 2.2 编译器做了什么

简单来说，编译器就是将高级语言翻译成机器语言的一个工具，编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。

![image-20230508090948579](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230508090948579.png)

## 2.3 链接器年龄比编译器长

## 2.4 模块拼装----静态链接

最基本的静态链接过程如下图：每个模块的源代码文件经过编译器编译成目标文件（Object file），目标文件和库一起链接形成最终可执行文件。

![image-20230508134301779](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230508134301779.png)

# 3 目标文件里有什么

编译器编译源代码后生成的文件叫做目标文件（就是编译后生成的Object file），目标文件从结构上来讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。

## 3.1 目标文件的格式

​	现在PC平台流行的可执行文件格式（Executable）主要是Windows下的PE（Portable Executable）和linux的ELF（Executable Linkable Format），它们都是COFF（Common file format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（windows的.obj和linux下的.o），它跟可执行文件的内容与结构很相似，所以一般跟可执行文件采用同一种格式存储。除此之外动态链接库（DLL， Dynamic Linking Library）(Windows 的.dll 和linux的.so)以及静态链接库（Static Linking Library）(Windows 的.lib 和linux的.a)文件都按照可执行文件格式存储。

> 静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，可以简单地把它理解为一个包含很多目标文件的文件包。

ELF文件标准里面把系统中采用ELF格式的文件归为如下表所列举的四类。

| ELF文件类型                        | 说明                                                         | 实例                                      |
| ---------------------------------- | ------------------------------------------------------------ | ----------------------------------------- |
| 可重定位文件（Relocatable File）   | 这类文件包含了代码和数据，可以被用来链接                     | linx的.o, windows的.obj                   |
| 可执行文件（Executable File）      | 这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，它们一般没有扩展名 | 比如/bin/bash文件和windows下的.exe        |
| 共享目标文件（Shared Object File） | 这种文件包含了代码和数据，可以在一下两种情况下使用，一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行。 | Linux的.so，如/lib/glbic.so，windows的DLL |
| 核心转储文件（core dump file）     | 当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 | linux下的core dump                        |

## 3.2 目标文件是什么样的

目标文件将链接时所需要的一些信息比如符号表、调试信息、字符串等按照不同的属性，以节（section）或者叫段（segment）的格式进行存储。程序源代码编译后的机器指令经常被放在代码段里（Code section）里，代码段常见的名字有".code"或".text"，全局变量和局部静态变量经常放在数据段（Data section）里。

总的来说，程序源代码被编译以后主要分为两种段：程序指令和程序数据，代码段属于程序指令，而数据段和.bss段属于程序数据。

这些段和会汇编里一样。

## 3.3 挖掘SimpleSection.o

以simpleSection.c 这段代码为例，进行分析。[代码参考链接](https://github.com/miaoski/xiuyang/tree/master)

```
int printf(const char *format, ...);

int global_init_var = 84;
int global_uninit_var;

void func1(int i) {
	printf("%d\n", i);
}

int main(void) {
	static int static_var = 85;
	static int staic_var2;

	int a = 1;
	int b;

	func1(static_var + staic_var2 + a + b);

	return a;
}
```

编译文件：

```
gcc -c SimpleSection.c # 参数-c 表示只编译不链接
```

默认生成的文件是a.out，如果想要设置生成的文件名，需要加上-o参数

```
gcc -c SimpleSection.c  -o SimpleSection.o
```

然后我们可以使用binutils的工具objdump来查看object内部的结果，

```
objdump -h SimpleSection.o # 输入这个命令查看
```

![image-20230508210634945](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230508210634945.png)

各个段的含义如下，和书上相比，多了一个[.eh_frame段](https://zhuanlan.zhihu.com/p/416947116)。

.text为代码段，存放程序源代码编译后的机器指令。

.data为数据段，存放已初始化的全局变量和局部静态变量

.bss为数据段， 存放未初始化的全局变量和局部静态变量

.rodata为只读数据段

.conment为注释信息段

.note.GUN-stack为堆栈段

.eh_frame为调试信息段

段的属性：长度（Size）、所在位置（File Offset）、Contents表示该段在文件中存在，BSS段没有Contents，表示它实际上在ELF文件中不存在内容，**.note.GNU-stac**k 虽然有Contents属性，但是它的长度为零（先暂时忽略掉它，认为它在ELF文件中不存在）

![image-20230509133650924](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230509133650924.png)

它们在ELF中的结构如图所示：这个和上面我在自己电脑上截的那张图不太一样，因为File Offset 不太一样。先用书上那种图。

![image-20230509133525783](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230509133525783.png)

### 3.3.1 代码段

objdump的**-s**参数可以将所有段的内容以十六进制的形式打印出来，"-d"参数可以将所有包含指令的段反汇编，部分截图如下：

![image-20230509134623490](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230509134623490.png)

完整版内容在这里。

```
objdump -s -d SimpleSection.o

SimpleSection.o:     file format elf32-i386

Contents of section .text:
 0000 5589e583 ec0883ec 08ff7508 68000000  U.........u.h...
 0010 00e8fcff ffff83c4 1090c9c3 8d4c2404  .............L$.
 0020 83e4f0ff 71fc5589 e55183ec 14c745f0  ....q.U..Q....E.
 0030 01000000 8b150400 0000a100 00000001  ................
 0040 c28b45f0 01c28b45 f401d083 ec0c50e8  ..E....E......P.
 0050 fcffffff 83c4108b 45f08b4d fcc98d61  ........E..M...a
 0060 fcc3                                 ..
Contents of section .data:
 0000 54000000 55000000                    T...U...
Contents of section .rodata:
 0000 25640a00                             %d..
Contents of section .comment:
 0000 00474343 3a202855 62756e74 7520352e  .GCC: (Ubuntu 5.
 0010 342e302d 36756275 6e747531 7e31362e  4.0-6ubuntu1~16.
 0020 30342e31 32292035 2e342e30 20323031  04.12) 5.4.0 201
 0030 36303630 3900                        60609.
Contents of section .eh_frame:
 0000 14000000 00000000 017a5200 017c0801  .........zR..|..
 0010 1b0c0404 88010000 1c000000 1c000000  ................
 0020 00000000 1c000000 00410e08 8502420d  .........A....B.
 0030 0558c50c 04040000 28000000 3c000000  .X......(...<...
 0040 1c000000 46000000 00440c01 00471005  ....F....D...G..
 0050 02750043 0f03757c 06730c01 0041c543  .u.C..u|.s...A.C
 0060 0c040400                             ....

Disassembly of section .text:

00000000 <func1>:
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
   6:	83 ec 08             	sub    $0x8,%esp
   9:	ff 75 08             	pushl  0x8(%ebp)
   c:	68 00 00 00 00       	push   $0x0
  11:	e8 fc ff ff ff       	call   12 <func1+0x12>
  16:	83 c4 10             	add    $0x10,%esp
  19:	90                   	nop
  1a:	c9                   	leave
  1b:	c3                   	ret

0000001c <main>:
  1c:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  20:	83 e4 f0             	and    $0xfffffff0,%esp
  23:	ff 71 fc             	pushl  -0x4(%ecx)
  26:	55                   	push   %ebp
  27:	89 e5                	mov    %esp,%ebp
  29:	51                   	push   %ecx
  2a:	83 ec 14             	sub    $0x14,%esp
  2d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
  34:	8b 15 04 00 00 00    	mov    0x4,%edx
  3a:	a1 00 00 00 00       	mov    0x0,%eax
  3f:	01 c2                	add    %eax,%edx
  41:	8b 45 f0             	mov    -0x10(%ebp),%eax
  44:	01 c2                	add    %eax,%edx
  46:	8b 45 f4             	mov    -0xc(%ebp),%eax
  49:	01 d0                	add    %edx,%eax
  4b:	83 ec 0c             	sub    $0xc,%esp
  4e:	50                   	push   %eax
  4f:	e8 fc ff ff ff       	call   50 <main+0x34>
  54:	83 c4 10             	add    $0x10,%esp
  57:	8b 45 f0             	mov    -0x10(%ebp),%eax
  5a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  5d:	c9                   	leave
  5e:	8d 61 fc             	lea    -0x4(%ecx),%esp
  61:	c3                   	ret
donglijie@ubuntu:tmp$
```

“Contents of section .text” 就是.text的数据以十六进制方式打印出来的内容，总共是0x5b（十进制就是91）字节,最左边一列是偏移量，中间四列是十六进制内容，最右边一列是。text段的ASCII码形式。对照下面的反汇编结果可以看到.text段里包含的正是SimpleSection.c里的两个函数func1()和main()的指令。

我自己在本地执行的结果，.text段的长度是0x62字节（共98字节），截图里面两个数字就是一个字节，所以一共是有24*4 + 2 = 98字节，是没有问题的。

### 3.3.2 数据段和只读数据段

.data 段保存的是那些已经初始化了的全局静态变量和局部静态变量。SimpleSection.c代码里一共有两个这样的变量，分别是global_init_varabal与static_var，这两个变量每个4个字节，一共8个字节，所以.data 这个段大小为8个字节。

.rodata 只读数据段，存放的是字符串常量"%d\n"，这个是在printf中用到的。但是有时候编译器会把字符串常量放到".data"段，而不会单独放到“.rodata”段（书上举的例子是把SimpleSection.c的文件名改成SimpleSection.cpp）。

### 3.3.3 BSS段

.bss 段存放的是未初始化得到的全局变量和局部静态变量，存储在.bss段的是global_uninit_var和static_var2被存放在.bss段，但是该段实际大小只有4个字节，按理说应该是8个字节，实际上只有static_var2被存放在了.bss段，global_uninit_var并没有（这个可以通过符号表看到，后面章节会讲），为什么这样，这个是跟不同的语言和不同的编译器实现有关。

例如下面这两个变量会放在哪个段中呢？

```
static int x1=0;
static int x2=1;
```

x1会被放到.bss中，x2会被放在.data中，原因是因为x1为0，可以认为是未初始化的，以为未初始化的都是0，所以被放在了.bss中，这样可以节省磁盘空间，因为.bss不占磁盘空间，而x2被初始化为1，所以存在了.data段中。

### 3.3.4其他段

### 3.3.5 自定义段

如果我们想把变量或者某些部分代码放到我们制定的段中去，以实现某些特定的功能，就可以使用自定义段。

![image-20230509203029290](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230509203029290.png)

## 3.4 ELF文件结构描述

总体结构如下：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230509203340197.png" alt="image-20230509203340197" style="zoom:50%;" />

### 3.4.1 文件头

查看ELF文件头

```
readelf -h SimpleSection.o
输入结果：
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          832 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           40 (bytes)
  Number of section headers:         13
  Section header string table index: 10
```

ELF文件头结构及相关常数被定义在/usr/include/elf.h 文件里。ELF文件有32位和64位版本，它的文件头结构也有这两种版本，分别叫做"Elf32_Ehdr"和"Elf64_Ehdr"，32位和64位的ELF文件的文件头结构内容是一样的，只不过有些成员的大小不一样。

![image-20230509204224061](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230509204224061.png)

**ELF文件头结构成员定义**

![image-20230510095640407](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510095640407.png)

![image-20230510095730591](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510095730591.png)

**ELF魔数**

从readelf中可以看到，最前面的“Magic”的16个字节刚好对应Elf32_Ehdr的e_ident成员，这16个字节被用来标识ELF文件的平台属性，0x7F、0x45、0x4c、0x46，是所有ELF文件都必须相同的标识码，第一个字节对应ASCII码中的DEL控制符，后面3个字节刚好是ELF三个字母的ASCII码。

第五个字节用来标识ELF文件类型，0x01表示32位，0x02 表示64位。

第六个字节用来标识字节序，规定该ELF文件是大端的还是小端的。

第七个字节规定ELF文件的主版本号，一般是1，因为ELF标准自1.2版本以后就么有更新了。

剩余的九个字节ELF标准没有定义，一般填0。

几乎所有的可执行文件格式的最开始几个字节都是魔数，比如a.out最开始的两个字节是0x01、0x07，PE/COFF文件最开始的连个字节为0x4d、0x5a。

**文件类型**

e_type 成员表示ELF文件类型。系统是通过这个常量来判断ELF的真正文件类型。

![image-20230510120016548](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510120016548.png)

**机器类型**

表示该文件可以在哪个平台上使用。

![image-20230510120313244](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510120313244.png)

### 3.4.2 段表

ELF文件中有很多段，段表就是保存这些段基本属性的结构。段表在ELF文件中的位置由ELF文件头的“e_shoff”成员决定。objdump -h 只是把ELF文件中关键的段显示了出来，其他的段没有显示，可以使用readelf 来查看ELF文件的段，它显示的就是真正的段表结构。

![image-20230510132318260](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510132318260.png)

段表是一个以“Elf32_Shdr”结构体为元素的数组，数组元素的个数等于段的个数，每个“Elf32_Shdr”结构体对应一个段，“Elf32_Shdr”又被称为段描述符（长度是40个字节），从上面来看SimpleSection.o 有13个段，书上是有11个，**ELF段表的这个数组的第一元素是无效的段描述符，它的类型是NULL**

Elf32_Shdr 结构体被定义在"/usr/include/elf.h"文件里，如下图所示：

![image-20230510133932446](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510133932446.png)

每个参数的含义如下图：

![image-20230510134030100](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510134030100.png)

段的名字只是在链接和编译过程中有意义，但是它不能真正的表示段的类型，对于编译器和连接器来说，主要决定段的属性的是段的类型（sh_type）和段的标志位（sh_flags）。

**段的类型**。

![image-20230510135848335](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510135848335.png)

![image-20230510135900267](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510135900267.png)

**段的标志位**

![image-20230510140310096](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510140310096.png)

**段的链接信息（sh_link、sh_info）**

![image-20230510141045215](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510141045215.png)

### 3.4.3 重定位表

对于每个需要重定位的代码段或数据段，都会有有一个相应的重定位表，比如SimpleSection.o中的".rel.text"就是针对".text"段的重定位表，因为".text"段中至少有一个绝对地址的引用，那就是对printf函数的调用。

详细的内容等下一章再详细分析。

### 3.4.4 字符串表

ELF文件中用到了很多字符串，比如段名、变量名，因为字符串的长度往往是不固定的，所以用固定的结构来表示它比较困难，一种很常见的做法是把字符串集中起来存放在一个表，然后使用字符串在表中的偏移来引用字符串。

## 3.5 链接的接口——符号

在链接中，我们将函数和变量统称为**符号（Symbol）**，函数名或者变量名就是符号名**（Symbol Name）**，每一个目标文件都会有一个相应的**符号表（Symbol Table）**,这个表里记录了目标文件中所用到的所有符号，每个定义的符号有一个对应的值，叫做符号值。对于变量和函数来说，符号值就是它们的地址，除了函数和变量之外，还有其他几种不常用到的符号。如下图：

![image-20230510144758775](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510144758775.png)

我们可以使用“nm”来看“SimpleSection.o”的符号结果如下：

![image-20230510144858974](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510144858974.png)

### 3.5.1 ELF符号表结构

ELF文件中的符号表往往是文件中的一个段，段名一般叫".symtab"，符号表的结构很简单，它是一个Elf32_Sym结构（32位ELF文件）的数组，每个Elf32_Sym结构对应一个符号。这个数组的一个元素，也就是下标为0的元素为无效的“未定义符号”,Elf32_Sym结构定义如下：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510150330520.png" alt="image-20230510150330520" style="zoom:50%;" />

各个字段说明如下：

![image-20230510150423137](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510150423137.png)

**符号类型和绑定信息（st_info）**

该成员低4位表示符号的类型，高28位表示符号绑定信息。

![image-20230510150828677](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510150828677.png)

**符号所在段（st_shndx）**

如果符号定义在本目标文件中，那么这个成员表示符号所在段表中的下标，但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，st_shndx的值有些特殊，如下表所示：

![image-20230510151121157](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510151121157.png)

**符号值（st_value）**

每个符号都有一个对应的值，如果这个符号是一个函数或变量的定义，那么符号就是这个函数或变量地址，更准备地讲应该按照下面这几种情况区别对待。

![image-20230510152035229](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510152035229.png)

![image-20230510152048420](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510152048420.png)

查看SimpleSection.o里面的符号，使用命令：readelf -s SimpleSection.o

![image-20230510152241355](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510152241355.png)

![image-20230510152928246](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510152928246.png)

![image-20230510152944494](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510152944494.png)

### 3.5.2 特殊符号

当我们使用ld作为链接器来链接生成可执行文件时，它会为我们定义很多特殊的符号，这些符号我们没有定义，但是我们可以直接声明并使用它。如下：

![image-20230510154116927](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510154116927.png)

示例如下：

![image-20230510154616245](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510154616245.png)

### 3.5.3 符号修饰与函数签名

这个是为了解决命名冲突的问题。

**C++符号修饰**

C++ 拥有类、继承、虚机制、重载、名称空间等这些特性。它们使用的符号管理更为复杂，比如两个相同名字的函数func(int)和func(double)，编译器和链接器在链接过程中如何区分这两个函数，为了支持C++这些复杂的特性，人们发明了符号修饰（Name Decoration）或符号改编（Name Managling）。 **函数签名**包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息，函数签名用于识别不同的函数。

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510160209828.png" alt="image-20230510160209828" style="zoom:50%;" />

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510160224377.png" alt="image-20230510160224377" style="zoom:50%;" />

比如上面这段C++代码，里面有6个同名函数func，按照函数签名，它们是不一样的。它们对应的修饰后名称如下：

![image-20230510160118364](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510160118364.png)

签名和名称修饰机制不光被使用函数上，C++中的全局变量和静态变量也有同样的机制。

### 3.5.4 extern "C"

C++编译器会将在extern "C"的大括号内部的代码当作C语言代码处理。

### 3.5.5 弱符号与强符号

对于C/C++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号，

## 3.6 调试信息

在gcc编译时加上-g参数，编译器就会在产生的目标文件里加上调试信息，

# 4 静态链接

如何把两个目标文件链接形成一个可执行文件，这个过程就是静态链接。

a.c

```
extern int shared;
int main()
{
 int a =100;
 swap(&a,&shared);
}
```

b.c

```
int shared = 1;
void swap(int *a, int *b)
{
  *a ^=*b ^=*a ^=*b;
}
```

编译：

```
gcc -c a.c b.c # 生成两个文件a.o 和b.o
 gcc -c b.c a.c  -fno-stack-protector # 用上面的命令不行，执行下面的ld命令会报错。
```

## 4.1 空间与地址分配

对于目标文件a.o 和b.o每个文件里都有很多段，链接器如何将它们的各个段合并到输出文件？

### 4.1.1 按序叠加

一个最简单的方案就是将输入的目标文件按照次序叠加起来，如下图

![image-20230510192820225](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510192820225.png)

这种方式会造成空间浪费。

### 4.1.2 相似段合并

将相同性质的段合并到一起。例如将所有输入文件的.text段合并到输出文件的.text段。接着是.data段、.bss段等。如下图所示：

![image-20230510193347807](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510193347807.png)

现在的链接器空间分配的策略基本上都采用了第二种方法，使用这种方法的链接器一般都采用一种叫做**两步链接**的方法，第一步空间与地址分配，第二步符号解析与重定位。

![image-20230510194539659](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510194539659.png)

使用ld链接器将a.o和b.o链接起来。

```
ld a.o b.o -e main -o ab
```

- -e 表示将main函数作为程序入口，ld链接器默认的程序入口为_start
- -o 表示链接输出文件名为ab，默认为a.out

![image-20230510200110371](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230510200110371.png)

VMA表示虚拟地址，LMA表示加载地址，正常情况下这两个值应该是一样的（在一些嵌入式系统中是不一样的），这里我们只关注VMA即可。

​	链接前目标文件中所有段的VMA都是0，因为虚拟空间还没有分配，等到链接后才会分配VMA。

![image-20230511212009389](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230511212009389.png)

在linux下，ELF可执行文件默认从地址0x08048000开始分配。

### 4.1.3 符号地址的确定

就是在最终的目标文件里给每个符号加上一个偏移量，调整到正确的虚拟地址。

## 4.2 符号解析与重定位

### 4.2.1 重定位

可以先看下a.o里面是怎么使用“shared”变量和“swap”函数的。

### 4.2.2 重定位表

在ELF文件中有一个重定位表，专门用来保存重定位相关的信息。对于每一个要被重定位的段都会有一个对应的重定位表。比如代码段里有要重定位的地方，那么会有一个相对应的叫做.rel.text的段保存了代码段的重定位表。

可以使用objdump -r 查看目标文件里的重定位表的内容。

![image-20230513115100858](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230513115100858.png)

![image-20230513115243565](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230513115243565.png)

### 4.2.3 符号解析

当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址，这个时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。查看文件的符号表如下：

![image-20230513120403073](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230513120403073.png)

shared 和swap是undefined。

### 4.2.4 指令修正方式

有些复杂，暂时不看了。

## 4.3 Common块

针对多个符号类型不一致的情况，也就导致所占符号所占空间不一样，（这里叫符号，我感觉叫变量更合适），最终会以符号占用最大的空间为准。

## 4.5 静态库链接

查看静态库有哪些文件使用ar命令

## 4.6 链接过程控制

### 4.6.1 链接控制脚本

控制链接过程有三种方法：

- 使用命令行来给链接器制定参数，前面使用的ld的-o、-e参数就属于这一类。
- 将链接指令存放在目标文件里，编译器经常会通过这种方法向链接器传递指令。
- 使用链接控制脚本（Visual C++把这种控制脚本叫做模块定义文件，它们的扩展名一般为.def）。

如果我们没有指定脚本的话，ld会使用默认的脚本。可以使用ld -verbose 查看默认的链接脚本。

### 4.6.4 ld链接脚本语法简介

暂时先跳过，

## 4.7 BFD库

BFD库期望通过一种统一的接口来处理不同的目标文件格式。

# 5 Windows PE/COFF

## 5.1 Windows的二进制文件格式PE/COFF

windows平台的文件结构：目标文件默认为COFF格式，可执行文件为PE格式。

这一章直接跳过吧。

# 第三部分装载与动态链接

# 6 可执行文件的装载与进程

##  6.1 进程虚拟地址空间

每个程序被运行起来后，它将拥有自己独立的虚拟地址空间（VMA），这个地址空间的大小是由CPU的位数决定的，

在32位系统里，1GB的空间被操作系统用了，剩下的3G空间可以被用户进程使用。

## 6.2 装载的方式

动态装入：将程序最常用的部分驻留在内存中，而将一些不太常用的数据放在磁盘里面。

动态装入分为两种：覆盖装入（Overlay）和页映射（Paging）。它们都是用了程序的局部性原理。

### 6.2.1 覆盖装入

这种已经废弃，是由程序员手工将程序分割成若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存何时应该被替换掉。

### 6.2.2 页映射

## 6.3 从操作系统看可执行文件的装载

### 6.3.1 进程的建立

一个进程最关键的特征是它拥有独立的虚拟地址空间。创建进程会做的事情：

- 创建一个独立的虚拟地址空间。

  这个是创建映射函数所需要的数据结构。

- 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。

- 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。

### 6.3.2 页错误

当cpu打算执行程序的入口地址指令时，发现对应的页面是一个空页面，它就会任务这是一个页错误，cpu就会把控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。

## 6.4 进程虚存空间分布

### 6.4.1 ELF文件链接视图和执行视图

为了减少空间浪费，在ELF文件中把相同权限的段，把他们合并到一起当做一个段进行映射。

### 6.4.2 堆和栈

操作系统通过使用VMA来对进程的地址空间进行管理，进程在执行的时候还需要用到栈和堆等空间，它们在进程的虚拟空间中的表现也是以VMA的形式存在的。

## 6.5 Linux 内核装载ELF过程简介

