[Toc]

# 01 温故知新

计算机的核心：CPU、内存和I/O控制芯片。



![image-20230506140307450](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230506140307450.png)

运行库使用操作系统提供的系统调用接口，系统调用接口在实现中往往以软件中断的方式提供。

## 02 编译和链接

比如对于下面这段程序：

```
#include <stdio.h>
int main(){
	printf("Hello world!\n");
	return 0;
}
```

运行结果：

<img src="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230507220735498.png" alt="image-20230507220735498" style="zoom:50%;" />

上述过程可以分解为4个步骤：预处理（Prepressing）、编译（Compilation）、汇编（Assembly）、链接（Linking）。

![image-20230507221011980](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230507221011980.png)

### 2.1.1 预编译

将源代码文件hello.c和相关的头文件，如stdio.h等被预编译器cpp预编译成一个.i文件。

预编译的过程相当于如下指令：

```
gcc -E hello.c -o hello.i
或者
cpp hello.c > hello.i
```

预编译主要的处理规则：

- 将所有的#define 删除，并展开所有的宏定义。
- 处理所有条件预编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”。
- 处理#include预编译指令，将被包含的文件插入到该预编译指令功能的位置（这个过程是递归进行的，也就说被包含的文件还可能包含其他文件）。
- 删除所有的注释
- 添加行号和文件名标识，比如#2“hello.c” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或者警告时能够显示行号。
- 保留所有的#pragma编译器指令。

### 2.1.2 编译

编译过程就是把预处理完的文件通过一系列词法分析、语法分析、语义分析及优化后产生相应的汇编代码文件。对应的命令就是：

```
gcc -S hello.i -o hello.s
gcc -S hello.c -o hello.s
```

现代版本的gcc把预编译和编译合成一个步骤，使用一个叫cc1的程序来完成这两个步骤。cc1程序在linux中位于/usr/lib/gcc/i686-linux-gnu/5目录下。而对于c++来说，对应的程序叫做cc1plus。

### 2.1.3 汇编

汇编器是将汇编代码转换为机器可以执行的指令，每个汇编语句几乎都对应一条机器指令，所以汇编过程相对于编译器来讲比较简单，它没有复杂的语法也没有语义，也不需要做指令优化。对应的命令：

```
as hello.s -o hello.o
gcc -c hello.s -o hello.o
gcc -c hello.c -o hello.o
```

### 2.1.4 链接

这是一个很复杂的过程，后面详细讲解。

## 2.2 编译器做了什么

简单来说，编译器就是将高级语言翻译成机器语言的一个工具，编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。

![image-20230508090948579](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230508090948579.png)

## 2.3 链接器年龄比编译器长

## 2.4 模块拼装----静态链接

最基本的静态链接过程如下图：每个模块的源代码文件经过编译器编译成目标文件（Object file），目标文件和库一起链接形成最终可执行文件。

![image-20230508134301779](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230508134301779.png)

# 3 目标文件里有什么

编译器编译源代码后生成的文件叫做目标文件（就是编译后生成的Object file），目标文件从结构上来讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或者有些地址还没有被调整。其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。

## 3.1 目标文件的格式

​	现在PC平台流行的可执行文件格式（Executable）主要是Windows下的PE（Portable Executable）和linux的ELF（Executable Linkable Format），它们都是COFF（Common file format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（windows的.obj和linux下的.o），它跟可执行文件的内容与结构很相似，所以一般跟可执行文件采用同一种格式存储。除此之外动态链接库（DLL， Dynamic Linking Library）(Windows 的.dll 和linux的.so)以及静态链接库（Static Linking Library）(Windows 的.lib 和linux的.a)文件都按照可执行文件格式存储。

> 静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，可以简单地把它理解为一个包含很多目标文件的文件包。

ELF文件标准里面把系统中采用ELF格式的文件归为如下表所列举的四类。

| ELF文件类型                        | 说明                                                         | 实例                                      |
| ---------------------------------- | ------------------------------------------------------------ | ----------------------------------------- |
| 可重定位文件（Relocatable File）   | 这类文件包含了代码和数据，可以被用来链接                     | linx的.o, windows的.obj                   |
| 可执行文件（Executable File）      | 这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，它们一般没有扩展名 | 比如/bin/bash文件和windows下的.exe        |
| 共享目标文件（Shared Object File） | 这种文件包含了代码和数据，可以在一下两种情况下使用，一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行。 | Linux的.so，如/lib/glbic.so，windows的DLL |
| 核心转储文件（core dump file）     | 当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 | linux下的core dump                        |

## 3.2 目标文件是什么样的

目标文件将链接时所需要的一些信息比如符号表、调试信息、字符串等按照不同的属性，以节（section）或者叫段（segment）的格式进行存储。程序源代码编译后的机器指令经常被放在代码段里（Code section）里，代码段常见的名字有".code"或".text"，全局变量和局部静态变量经常放在数据段（Data section）里。

总的来说，程序源代码被编译以后主要分为两种段：程序指令和程序数据，代码段属于程序指令，而数据段和.bss段属于程序数据。

这些段和会汇编里一样。

## 3.3 挖掘SimpleSection.o

以simpleSection.c 这段代码为例，进行分析。[代码参考链接](https://github.com/miaoski/xiuyang/tree/master)

```
int printf(const char *format, ...);

int global_init_var = 84;
int global_uninit_var;

void func1(int i) {
	printf("%d\n", i);
}

int main(void) {
	static int static_var = 85;
	static int staic_var2;

	int a = 1;
	int b;

	func1(static_var + staic_var2 + a + b);

	return a;
}
```

编译文件：

```
gcc -c SimpleSection.c # 参数-c 表示只编译不链接
```

默认生成的文件是a.out，如果想要设置生成的文件名，需要加上-o参数

```
gcc -c SimpleSection.c  -o SimpleSection.o
```

然后我们可以使用binutils的工具objdump来查看object内部的结果，

```
objdump -h SimpleSection.o # 输入这个命令查看
```

![image-20230508210634945](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20230508210634945.png)