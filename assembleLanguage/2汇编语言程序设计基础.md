[Toc]

# 05 传送数据

## 5.1 定义数据元素

### 5.1.1 数据段

使用.data命令声明数据段，在这个段中声明的任何数据元素都保留在内存中并且可以被汇编语言程序中的指令读取和写入。

另一种类型的数据段：.rodata，在这种数据段中定义的任何数据元素只能按照只读模式访问。

定义数据元素需要两个语句：一个标签和一个命令

| 命令    | 数据类型                     |
| ------- | ---------------------------- |
| .ascii  | 文本字符串                   |
| .asciz  | 以空字符串结尾的文本字符串   |
| .byte   | 字节值                       |
| .double | 双精度浮点数                 |
| .float  | 单精度浮点数                 |
| .int    | 32位整数                     |
| .long   | 32位整数（和.int相同）       |
| .octa   | 16字节整数                   |
| .quad   | 8字节整数                    |
| .short  | 16位整数                     |
| .single | 单精度浮点数（和.float相同） |

比如下面这个定义

```
#output 是标签，
output:
    .ascii "The processor Vendor ID is 'xxxxxxxxxxxx'\n"
# 把3.14159的浮点表示赋值给pi标签饮用的内存位置。
pi：
	.float 3.14159
# 可以在一行语句中定义多个值，不知道这个是不是和数组类似。
height：
	.int 54
length:
	.int 62, 35 ,47
```

按照数据段中定义数据元素的顺序，每个数据元素被放到内存中，带有多个值的元素按照命令中列出的顺序存放，如下图所示：

<img src="2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230405123219133.png" alt="image-20230405123219133" style="zoom:25%;" />

### 5.1.2 定义静态符号

使用.equ命令进行定义,.equ命令用于把常量值设置为可以在文本段中使用的符号。数据符号值在程序中是不能改动的。

```
.equ factor, 3
```

.equ命令可以出现在数据段中的任何位置，但是最好在定义其他数据之前或者之后集中定义所有数据符号。

引用静态数据元素，需要在标签名称前面使用美元符号($)，比如下面的指令把赋值给LINUX_SYS_CALL符号的值传送给EAX寄存器。

```
movl $LINUX_SYS_CALL, %eax
```

### 5.1.3 bss段

bss段中定义变量时无须声明特定的数据类型。gnu汇编器使用两个命令声明缓冲区。如下：

| 命令   | 描述                                 |
| ------ | ------------------------------------ |
| .comm  | 声明未初始化的数据的通用内存区域     |
| .lcomm | 声明未初始化的数据的本地通用内存区域 |

二者的区别：[参考链接](https://blog.csdn.net/ScottePerk/article/details/122145849)。

这两个命令格式：.comm symbol, length

symbol 是赋给内存区域的标签，length是内存区域中包含的字节数量。比如：

```
.section .bss
.lcomm buffer,10000
```

上面这条语句把10000字节的内存区域赋值给buffer标签，在声明本地通用内存区域的程序之外的函数是不能访问它们的（不能在.global命令中使用它们）。

在bss段中声明的数据不包含在可执行程序中，在数据段中定义数据时，它必须被包含在可执行程序中，因为必须使用特定值初始化它。[参考链接](https://www.jianshu.com/p/ddfb284c1f7a)

下面是几个例子：

```
#size1test1.s - A sample program to view the executable size1test1
.section .text
.globl _start
_start:
movl $1, %eax
movl $0, %ebx
int $0x80
```

编译连接

```
as -o sizetest1.o sizetest1.s
ld -o sizetest1 sizetest1.o
```

查看连接后的文件大小。

![image-20230405150540604](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230405150540604.png)

可执行文件，总长度是452字节。

创建另一个测试程序

```
#size1test2.s - A sample program to view the executable size
.section .bss
	.lcomm buffer,10000
.section .text
.globl _start
_start:
movl $1, %eax
movl $0, %ebx
int $0x80
```

编译命令

```
as -o sizetest2.o sizetest2.s
ld -o sizetest2 sizetest2.o
```

查看连接后的文件大小

![image-20230405151205695](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230405151205695.png)

可执行文件长度是596。

添加了一个缓冲区，但是可执行程序文件的长度只增加了23字节。

再创建第三个程序

这次使用.fill 命令再数据段中创建10000字节的缓冲区。

```
#size1test3.s - A sample program to view the executable size
.section .data
buffer:
	.fill 10000
.section .text
.globl _start
_start:
movl $1, %eax
movl $0, %ebx
int $0x80
```

文件大小如下，缓冲区空间的10000字节被添加到了可执行程序中。

![image-20230405151552272](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230405151552272.png)

## 5.2 传送数据元素

数据元素位于内存中，处理数据元素的第一步是在内存和寄存器之间传送它们。MOV指令用作通用的数据传送指令。

### 5.2.1 MOV指令格式

指令基本格式如下：movx source,destination

source和desination的值可以是内存地址、存储在内存中的数据值、指令语句中定义的数据值或者寄存器。

```
movx
    其中 x 可以是下面的字符：
      1，l用于32位的长字值
      2，w用于16位的字值
      3，b用于8位的字节值
      4，q用于64位的字节值
```

比如把32位EAX寄存器值传送给32位的EBX寄存器值，可以使用如下指令：

```
movl %eax，%ebx
```

对于16位寄存器，指令就是：

```
movw %ax, %bx
```

对于8位寄存器，指令就是：

```
movb %al, %bl
```

mov指令有非常特殊的规则，只对某些位置可以传送给其他位置，MOV指令的源和目标操作数组合如下所示：

- 把立即数据元素传送给通用寄存器
- 把立即数据元素传送给内存位置
- 把通用寄存器传送给另一个通用寄存器
- 把通用寄存器传送给段寄存器
- 把段寄存器传送给通用寄存器
- 把通用寄存器传送个控制寄存器
- 把控制寄存器传送给通用寄存器
- 把通用寄存器传送给调试寄存器
- 把调试寄存器传送给通用寄存器
- 把内存位置传送给通用寄存器
- 把内存位置传送给段寄存器
- 把通用寄存器传送给内存位置
- 把段寄存器传送给内存位置

### 5.2.2 把立即数传送到寄存器和内存

立即数是在指令码语句中直接指定的，并且在运行时不能改动。比如下面语句

```
movl $0, %eax # 把0传送给EAX寄存器
movl $ox80, %ebx # 把16进制数80 传送给EBX寄存器
movl $100, height # 把100传送给location的内存地址
```

在数字前面加上$符号，表明是立即数。

### 5.2.3 在寄存器之间传送数据

8个寄存器（EAX、EBX、ECX、EDX、EDI、ESI、EBP和ESP）是用于保存数据的最常用的寄存器。通用寄存器的内容可以传送给可用的任何其他类型的寄存器，而专用寄存器（控制、调试和段寄存器）的内容只能传送给通用寄存器，或者接收懂通用寄存器传送来的内容。

```
movl %eax, %ecx # 把32位数据从EAX寄存器传送给ECX寄存器
movw %ax,%cx # 16位数据从AX寄存器传送给CX寄存器
```

### 5.2.4 在内存和寄存器之间传送数据

#### 1、把数据值从内存中传送到寄存器

```
movl value, %eax
```

这条命令把位于value标签指定的内存位置的数据传送给EAX寄存器，MOVL指令传送32位的信息，它传送从value标签饮用的内存位置开始的4字节数据，如果数据长度小于4个字节，就必须使用其他MOV指令之一，比如MOVB用于1个字节或者MOVW用于2个字节。

```
#movtest1.s An example of moving data fomr memory to a register
.section .data
    value:
        .int 1
.section .text
.globl _start
    _start:
        nop
        movl value, %ecx
        movl $1, %eax
        movl $0, %ebx
        int $0x80
```

```
# 使用-gstabs参数，附加信息被汇编进可执行程序文件中，用来使用gdb超检查源代码
as -gstabs -o movtest1.o movtest1.s
ld -o movtest1 movtest1.o
```

使用gdb调试器运行这个程序: `gdb -q movtest1 `,这里-q选项不输出gdb版本信息。

![image-20230405165617986](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230405165617986.png)

先打个断点，然后再执行命令，通过下面的截图可以看到确实把值给拷贝到寄存器里了。

![image-20230405192231038](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230405192231038.png)

#### 2、把数据值从那寄存器传送回内存

使用的命令类似这样：`movl %ecx, value`

```
#movtest2.s An example of moving register data to memory
.section .data
    value:
        .int 1
.section .text
.globl _start
    _start:
        nop
        movl $100, %eax
        movl  %eax, value
        movl $1, %eax
        movl $0, %ebx
        int $0x80
```

编译，连接

```
as -o movtest2.o -gstabs movtest2.s
ld -o movtest2 movtest2.o
```

![image-20230405193750467](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230405193750467.png)

从上面的截图可以看出来，当执行了`movl %eax, value`以后，value的值就变成了100，value的值一开始是1，`movl $100, %eax`给寄存器的值设置成了100。

这里可以看到使用x命令好像可以不用指定长度。

#### 3、使用变址的内存（访问数组）

可以在一个命令中指定把多个值放到内存中，比如这样：

```
values：
	.int 10,15,20,25,30,35,40,45,50,55,60
```

​	这相当于就是创建了一个数组，引用数组中的数据时，必须使用变址系统确定要访问的是哪个值。

​	完成这种操作的方式称为变址内存模式，内存位置由下列因素确定：

- 基址
- 添加到基址上的偏移地址
- 数据元素的长度
- 确定选择那个数据元素的变址

表达式的格式：base_address (offset_address, index, size)

获取的数据值位于：base_address + offset_address + index * size

如果其中的任何值为零，就可以忽略（但是仍需要用逗号作为占位符）

例如，为了引用前面给出的values数组中的值20，可以使用下面的命令：

```
movl $2 , %edi
movl values(,%edi,4), %eax
```

这条指令把从values标签开始的第三个4字节的变址值加载到EAX寄存器中（数组是变址0开始）。大多数情况下，将使用一个寄存器计数器（ESI/EDI分别叫做"源/目标索引寄存器"(source/destination index)）作为变址值，并且改变这个值来匹配要处理的数组元素。

```
#movtest3.s An example of using indexed memory locations
.section .data
output:
    .asciz "The vlaue is%d\n"
values:
	.int 10,15,20,25,30,35,40,45,50,55,60
.section .text
.globl _start
_start:
    nop
    movl $0, %edi
# 定义一个循环
loop:
movl values(,%edi, 4), %eax
pushl %eax
pushl $output
call printf
addl $8, %esp
inc %edi
cmpl $11, %edi
jne loop
movl $0, %ebx
movl $1, %eax
int $0x80
    
        
```

如下：

![image-20230405203142908](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230405203142908.png)

由于代码里使用了c语言的函数printf，因此在声明output 变量的时候，使用的类型是.asciz，因为printf函数要求以空字结尾的字符串作为输出字符串。为了把参数传递给printf，需要把他们压入到堆栈，使用的PUSHL命令，参数放入堆栈的顺序和printf获取他们的顺序是相反的。所以先把eax 寄存器的值给放到堆栈里了，这里应该是因为栈是先入后出，所以才这样操作的。

[参考连接](https://www.jianshu.com/p/65a3dc42964c)

#### 4、使用寄存器间接寻址

寄存器除了保存数据以外，也可以保存地址，保存地址时，寄存器被称为指针，使用指针访问存储在内存位置中的数据被称为间接寻址，操作指针变量时需要在变量名前面加上美元符号。比如：

```
movl $values, %edi # 该命令用于把values标签饮用的内存地址传递给EDI寄存器。
movl %ebx,(%edi) # edi外面有括号，这条指令就把EBX寄存器中的值传送给EDI寄存器中包含的内存位置。不加括号的话，就只是把EBX寄存器中的值加载到EDI寄存器中。
```

gnu汇编器不允许把值与寄存器相加，如果需要相加的话，需要加上括号。

```
movl %edx, 4(%edi) # 把edx寄存器中的值，存放到edi寄存器指向的位置之后的4个字节的内存位置。
movl %edx, 4(%edi) # 把edx寄存器中的值，存放到edi寄存器指向的位置之前的4个字节的内存位置。
```

```
#movtest3.s An example of indirect addressing
.section .data
output:
    .asciz "The vlaue is%d\n"
values:
	.int 10,15,20,25,30,35,40,45,50,55,60
.section .text
.globl _start
_start:
    nop
# 把vlaues 数组的第一个元素赋值给eax寄存器中
movl values, %eax
# 把values在内存中的地址给放到edi寄存器中
movl $values, %edi
movl $100, 4(%edi)
movl $1, %edi
movl values(,%edi, 4), %ebx
movl $1, %eax
int $0x80
    
        
```

编译连接：

```
as -o movtest4.o -gstabs movtest4.s
ld -o movtest4 movtest4.o
```

使用gdb调试：

```
gdb -q movtes4
```

先打个断点：b * _start +1, 然后按r运行

![image-20230407082448333](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230407082448333.png)

可以看到接下来要执行的命令是：`movl values, %eax`

首先，values是一个数组，这句话是把values数组的第一个元素加载到eax寄存器（这个和c语言里很像，就是数组名就等同于数组的起始地址）。

以十进制形式打印values数组的前4个元素，使用的命令是`x/4d`

![image-20230407084250682](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230407084250682.png)

`x/4d`省略了以多少字节作为一个内存单元，默认是以4个字节作为一个内存单元，所以使用`x/4dw`也是可以的。如下图。

![image-20230407084820910](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230407084820910.png)

继续执行下一步，输入n或s可以看到eax寄存器的值就是values数组的第一个元素的值。

![image-20230407084915857](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230407084915857.png)

继续执行，在执行前可以先看下，edi寄存器的值是0，然后输入s执行，可以看到edi寄存器保存的值就是values数组的首地址。

![image-20230407085035243](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230407085035243.png)

下一条命令是把立即数100传送到edi寄存器指向的地址之后的4字节的内存地址，这个应该就是values数组第二个元素的地址。执行完那条命令以后，我们可以发现，values数组的值确实变了。

![image-20230407085332524](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230407085332524.png)

接下来的两条指令，第一条是先把1给传送edi寄存器，这个时候，edi寄存器的值就是1，然后再执行第二条命令，把values数组的第二个元素给放到ebx寄存器中。

![image-20230407085703685](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230407085703685.png)

程序的其余部分是使用Linux系统调用exit终止程序，程序的退出码应该是被存放到EBX寄存器中的新创建的第二个数据数组元素（100），可以通过在shell中查看退出码来检查这个值，这个是使用特殊的环境变量$完成的。

![image-20230407090804579](2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.assets/image-20230407090804579.png)

### 5.3 条件传送指令

#### 5.3.1 CMOV指令

条件传送指令都具有如下格式：

```
cmovx source, destination
```

x是一个或者两个字母的代码，表示将要触发传送操作的条件，条件取决于EFLAGS寄存器的当前值。

条件传送指令使用的特定位如下表：

| EFLAGS位 | 名称                   | 描述                             |
| -------- | ---------------------- | -------------------------------- |
| CF       | 进位（Carry）标志      | 数学表达式产生了进位或者借位     |
| OF       | 溢出（Overflow）标志   | 整数值过大后者过小               |
| PF       | 奇偶校验（Parity）标志 | 寄存器包含数学操作造成的错误数据 |
| SF       | 符号（Sign）标志       | 指出结果为正还是负               |
| ZF       | 零（Zero）标志         | 数学操作的结果为0                |

条件传送指令分为用于带符号操作的指令和用于无符号操作（会忽略符号标志的比较）的指令。

| 指令对        | 描述                | EFLAGS标志   |
| ------------- | ------------------- | ------------ |
| CMOVA/CMOVNBE | 大于/不小于或者等于 | (CF或ZF) = 0 |
| CMOVAE/CMOVNB | 大于或者等于/不小于 | CF = 0       |
| CMOVNC        | 无进位              | CF = 0       |
| CMOVB/CMOVNAE | 小于/不大于或者等于 | CF = 1       |
| CMOVC         | 进位                | CF = 1       |
| CMOVBE/CMOVNA | 小于或者等于/不大于 | (CF或ZF) = 1 |
| CMOVE/CMOVZ   | 等于/零             | ZF = 1       |
| CMOVNE/CMOVNZ | 不等于/不为零       | ZF = 0       |
| CMOVP/CMOVPE  | 奇偶校验/偶校验     | PF = 1       |
| CMOVNP/CMOVPO | 非奇偶校验/奇校验   | PF = 0       |

带符号操作指令

| 指令对        | 描述                | EFLAGS标志            |
| ------------- | ------------------- | --------------------- |
| CMOVGE/CMOVNL | 大于或者等于/不小于 | (SF异或OF) = 0        |
| CMOVL/CMOVNGE | 小于/不大于或者等于 | (SF异或OF) = 1        |
| CMOVLE/CMOVNG | 小于或者等于/不大于 | ((SF异或OF) 或ZF) = 0 |
| CMOVO         | 溢出                | OF = 1                |
| CMOVNO        | 未溢出              | OF = 0                |
| CMOVS         | 带符号（负）        | SF = 1                |
| CMOVNS        | 无符号（非负）      | SF = 0                |

条件传送指令需要某种类型的数学指令来设置EFLAGS寄存器以便进行操作。

例如下面这几条指令：

```
movl value,%ecx # 把value标签引用的值加载到ECX寄存器中
cmp %ebx, %ecx 
cmova %ecx, %ebx # 如果ecx寄存器中的值大于ebx寄存器中的原始值，就使用CMOVA指令把EBX的值替换为ECX中的值。
简单来说就是下面这样
if(ecx > ebx){
  ebx = ecx 
}
```

[参考链接](https://blog.csdn.net/npu2017302288/article/details/109171692)

> ，我突然想到，at&t语法中，source和destination，实际上就是一个表达式两边的变量，比如 movl value, %ecx, 这里source 就是value， destination就是ecx寄存器，它实际上就是 %ecx = value， 也就是说destination对应的就是操作符左边的变量，而source就是操作符右边的变量。

### 5.3.2 使用CMOV指令

```
# cmovtest.s an example of the CMOV instructions
.section .data
output:
    .asciz "The largest value is %d\n"
values:
    .int 105, 235, 61, 315, 134, 221, 53, 145, 117, 5
.section .text
.globl _start
_start:
  nop
  # 把数组的第一个元素赋值给ebx寄存器
  movl values, %ebx
  # edi寄存器存储遍历values数组的索引
  movl $1, %edi
loop:
    movl values(, %edi, 4) , %eax # 依次把 values数组的元素给放到eax寄存器里
    cmp %ebx, %eax # 把eax中的值和ebx中的值进行比较
    cmova %eax, %ebx # 如果eax中的值大于ebx中的值，就把eax的值赋值给ebx寄存器
    inc %edi # 增加edi寄存器中索引的值
    cmp $10, %edi # 比较edi 和10
    jne loop # 跳出循环
pushl %ebx # 下面的这些是打印和退出语句。
pushl $output
call printf
addl $8, %esp
pushl $0
call exit
```

编译链接：

```
as -o cmovtest.o -gstabs cmovtest.s
ld -dynamic-linker /lib/ld-linux.so.2 -lc -o cmovtest cmovtest.o
```

