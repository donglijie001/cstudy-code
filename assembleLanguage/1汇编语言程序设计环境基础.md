[Toc]

# 王爽

https://github.com/bobli1128/Assembly-Language

 [汇编语言王爽着.pdf](../../../../Downloads/汇编语言王爽着.pdf) 

# 1 什么是汇编语言

## 1.1 处理器指令

处理器芯片中预置的代码称为**指令码**。

指令码格式：

- 可选的指令前缀

  指令前缀可以包含1到4个修改操作码行为的1字节前缀，按照前缀功能，可以分为四个组。每个组的前缀最多只能使用一个（因此最多有4个前缀字节），四个前缀组如下：

  - 锁定前缀和重复前缀

    锁定前缀表示指令将独占地使用共享内存区域，重复前缀用于表示重复的功能。

  - 段覆盖前缀和分支提示前缀

    段覆盖前缀可以覆盖定义了的段寄存器值的指令，分支提示前缀尝试向处理器提供程序在条件跳转语句中最可能的路径线索。

  - 操作数长度覆盖前缀

    通知处理器程序将在这个操作码之内切换16位和32位的操作数长度。

  - 地址长度覆盖前缀

    通知处理器程序将切换16位和32位的内存地址。

- 操作码（opcode）

  唯一地定义要执行的功能。

- 可选的修饰符

  一些操作码需要另外的修饰符来定义执行的功能中涉及到什么寄存器和内存位置，修饰符包含在3个单独的值中：

  - 寻址方式说明符（ModR/M）字节

    这个是由三个字段的信息构成

    ![image-20230327135902223](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230327135902223.png)

    mod字段和r/m字段一起使用，用于定义指令中使用的寄存器或者寻址模式。

    reg/opcode字段用于允许使用更多的3位进一步定义操作码功能，或者可以用于定义寄存器值。

    r/m字段用于定义用作该功能的操作数的另一个寄存器，或者可以把它和mod字段组合在一起定义指令的寻址模式。

  - 比例-索引-基址（SIB）字节

    ![image-20230327140329604](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230327140329604.png)

    ![image-20230327140529652](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230327140529652.png)

  - 1、2或者4个地址移位字节

    ![image-20230327140554365](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230327140554365.png)

- 可选的数据元素

  最后一部分是该功能使用的数据元素。

![image-20230327134729413](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230327134729413.png)

## 1.2 汇编语言

汇编语言由三个部分组成：

- 操作码助记符
- 数据段
- 命令

### 1.2.1 操作码助记符

助记符感觉实际上就是对指令码的抽象，起了一个别名。

# 2 IA-32平台

## 2.1 IA-32 处理器的核心部分

![image-20230328003634930](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230328003634930.png)

处理器包含控制计算机操作的硬件和指令码。

控制总线用于保持处理器和各个系统元素之间功能的同步。

数据总线用于在处理器和外部系统元素之间传送数据。

地址总线就是处理器要操作数据的时候，把地址通过地址总线发送过去。

处理器的主要组件：

- 控制单元

  基本功能有：从内存中获得指令、对指令进行解码以便进行操作、从内存获得所需的数据、如果必要，就存储结果。

- 执行单元

  主要功能是执行指令。由一个或者多个运算逻辑单元构成。

- 寄存器

  存储要处理的数据。下面的指令指针寄存器就是程序计数器。

  ![image-20230328090822962](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230328090822962.png)

  **通用寄存器**

  ​	用于临时地存储数据。

  | 寄存器 | 描述                           |
  | ------ | ------------------------------ |
  | EAX    | 用于操作数和结果数据到累加器   |
  | EBX    | 指向数据内存段中的数据的指针   |
  | ECX    | 字符串和循环操作的计数器       |
  | EDX    | I/O指针                        |
  | EDI    | 用于字符串操作的目标的数据指针 |
  | ESI    | 用于字符串操作的源的数据指针   |
  | ESP    | 堆栈指针                       |
  | EBP    | 堆栈数据指针                   |

- 标志

  用来确认处理实现的操作是否成功。分为三种：状态标志、控制标志、系统标志。

  

  

![image-20230328085608802](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230328085608802-9964972.png)

# 3 相关工具

## 3.1 GNU 汇编器

gnu汇编器称为（gas）

**安装**

运行：`dpkg -l | grep binutils`可以看到已经安装了汇编器。

![image-20230328220843432](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230328220843432.png)

**使用汇编器**

命令行可执行程序是as。

![image-20230328221537510](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230328221537510.png)

参数如下：

![image-20230328221552130](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230328221552130.png)

![image-20230328221628594](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230328221628594.png)

## 3.2 GNU 连接器

GNU连接器ld用于把目标文件连接为可执行程序文件或者库文件。



## 3.3 下载和安装gcc

这个直接参考mit6.828 课程里的gcc 安装进行配置。

# 4 汇编语言程序范例

由于我使用的是虚拟机，因此我写代码是在我的主机上，需要把代码给同步到mac上。这里我准备使用rsync 命令进行同步。[rsync 参考链接](https://www.ruanyifeng.com/blog/2020/08/rsync.html)。

`rsync -av cstudy-code donglijie@192.100.219.111:/home/donglijie`

## 4.1 创建简单程序

### 4.1.1 CPUID指令

它用于请求处理器的特定信息并把信息返回到特定的寄存器中。该指令根据EAX寄存器的值作为输入，生成厂商ID字符串返回到到EBX、ECX、EDX寄存器。

![image-20230329221025682](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230329221025682.png)

EBX包含字符串最低4个字节

EDX包含字符串中间4个字节

ECX包含字符串最高4个字节

汇编程序的一般结构

<img src="1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230329224044365.png" alt="image-20230329224044365" style="zoom:25%;" />

模版如下：

![image-20230329224151420](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230329224151420.png)

汇编语言有三种注释：

对于注释符号，AT&T允许了3种注释符号，c/c++的两种（**单行注释“//”和多行注释“/\**/”），还有"#"单行注释**，值得注意的是，“//”虽然可以单行注释，但只能放在空行注释，其他两个注释均可以跟在代码行后面，"/**/"甚至允许你在代码行的最前面写一行注释。

.globl用于声明程序入口。

.section .text 声明代码段

代码里movl指令解释：

mov指令是数据传送指令，

GNU汇编器为 mov 指令添加了一个维度，在其中必须声明要传送的数据元素的长度。
  通过吧一个附加字符添加到 MOV 助记符来声明这个长度。
  因此，指令就变成了如下：

```
   movx source, destination
   movx
    其中 x 可以是下面的字符：
      1，l用于32位的长字值
      2，w用于16位的字值
      3，b用于8位的字节值
      4，q用于64位的字节值
```

编译，构建可执行程序

```
as -o cpuid.o cpuid.s
# ld用于把目标代码文件连接为可执行程序文件或者库文件。
ld -o cpuid cpuid.o
```

## 4.2 调试程序

使用-gstabs添加附加信息，用于调试。

```
as -gstabs -o cpuid.o cpuid.s
ld -o cpuid cpuid.o
```

单步运行程序：使用run命令从gdb内运行程序，一下子就把程序运行完了。![image-20230405170600591](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230405170600591.png)

现在需要在程序启动时停止它，需要设置断点。可以选择在写列任何情况停止程序的执行。

- 到达某个标签
- 达到源代码中的某个行号
- 数据值到达特定值时
- 函数执行了指定的次数之后

在汇编语言程序中指定断点时，必须指定对于最近的标签的相对位置，因为这个范例程序在指令码段中只有一个标签，所以每个断点都必须依据_start指定。

break * label + offset， 其中label是被引用的源代码中的标签。

可以在第一条指令设置断点。

```
break * _start
或者
b * _start
```

书上说的那个gdb的问题，在现在的gdb版本中已经没有了。

使用next（缩写是n） 或者step（缩写是s） 命令单步调试。

![image-20230405173224950](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230405173224950.png)

cont 继续执行，直到下一个断点结束。

![image-20230405173342314](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230405173342314.png)

查看数据

程序执行时，可以在每次停止时查看数据元素，有如下命令

| 数据命令       | 描述                                 |
| -------------- | ------------------------------------ |
| info registers | 显示所有寄存器的值                   |
| print          | 显示特定寄存器或者来自程序的变量的值 |
| x              | 显示特定内存位置的内容               |

在执行cpuid指令之前，EBX、ECX、EDX寄存器都为0.

![image-20230405174804107](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230405174804107.png)

cpuid指令执行之后，他们包含从厂商ID字符串得来的值。print 命令也可以用于显示各个寄存器的值，加上一个修饰符可以修改print命令输出格式：

- print/d 显示十进制的值
- print/t 显示二进制的值
- print/x显示十六进制的值

![image-20230405175842066](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230405175842066.png)

x命令用于显示特定内存位置的值，命令格式如下：x/nyz，其中n是要显示的字段数，y是输出格式，它可以是：

- c用于字符
- d用于十进制
- x用于十六进制

z：指以多少个字节作为一个内存单元，默认是4，

- b 1个字节
- h 2个字节
- w 4个字节

下面的例子使用x命令, &符号用于表示它是一个内存位置。

![image-20230405180248157](1%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80.assets/image-20230405180248157.png)

vscode 插件安装

由于书本里使用了gnu的汇编器，因此在vscode里，安装了GNU Assembler Language Support 插件，用于提高开发效率。目前来看只是语法高亮了，没有其他作用。
